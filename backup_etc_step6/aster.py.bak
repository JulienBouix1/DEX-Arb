# venues/aster.py
from __future__ import annotations
import asyncio
import json
import os
import time
import hmac
import hashlib
from typing import Dict, List, Optional, Callable, Tuple
from urllib.parse import urlencode

import websockets
import aiohttp

# === Réglages réseau ===
REST_WARMUP_TIMEOUT = 5.0
WS_PING_INTERVAL = 20.0
WS_PING_TIMEOUT = 10.0
RECONNECT_BASE_DELAY = 0.8
RECONNECT_MAX_DELAY = 8.0

# 2 streams/pair (depth@100ms + bookTicker) => on limite à ~16 streams par WS
PAIRS_PER_WS = 8

# Stale threshold (ms) avant tentative de re-warmup + re-sub
STALE_MS_DEFAULT = 12_000
STALE_MS = int(os.getenv("ASTER_STALE_MS", str(STALE_MS_DEFAULT)))

WATCHDOG_PERIOD_S = 5.0
RESUB_BACKOFF_MS = 7_000


class _Book:
    __slots__ = ("bid", "ask", "t")

    def __init__(self, bid: float = None, ask: float = None, t: float = None):
        self.bid = bid
        self.ask = ask
        self.t = t or time.time()

    def mid(self) -> Optional[float]:
        if self.bid is None or self.ask is None:
            return None
        return (self.bid + self.ask) / 2.0


class Aster:
    """
    Client Aster compatible avec arb_runner.py :
      - await connect()
      - await subscribe_orderbook("AVAXUSDT")
      - await stop()
      - get_book(symbol) -> (bid, ask, ts)
      - get_l2_book(symbol) -> {"bids":[(px,qty),...], "asks":[...]}  # NEW
      - start(symbols) -> warm-up bulk + WS
      - get_futures_balance_usd() -> equity USDT/USDC (si API signée ok)
    """

    def __init__(
        self,
        base_ws: str = "wss://stream.binance.com:9443/stream",
        base_rest: str = "https://api.binance.com",
        creds: dict | None = None,
    ):
        self.base_ws = base_ws.rstrip("/")
        self.base_rest = base_rest.rstrip("/")
        self.creds = creds or {}

        # Choix auto du chemin REST spot vs futures-like
        if ("fapi" in self.base_rest) or ("fstream" in self.base_ws):
            self._rest_ticker_path = "/fapi/v1/ticker/bookTicker"
            self._is_futures = True
        else:
            self._rest_ticker_path = "/api/v3/ticker/bookTicker"
            self._is_futures = False

        self._running = False
        self._books: Dict[str, _Book] = {}
        self._l2: Dict[str, Dict[str, List[Tuple[float, float]]]] = {}
        self._symbols: List[str] = []
        self._ws_tasks: List[asyncio.Task] = []
        self._poller_task: Optional[asyncio.Task] = None
        self._watchdog_task: Optional[asyncio.Task] = None

        self._last_update: Dict[str, float] = {}
        self._last_resub_try_ms: Dict[str, int] = {}

        self.logger: Optional[Callable[[str], None]] = None
        self._reconfigure_lock = asyncio.Lock()

        # API keys (lecture balance futures)
        self._api_key = (self.creds.get("api_key") if isinstance(self.creds, dict) else None) or os.getenv("ASTER_API_KEY", "")
        self._api_secret = (self.creds.get("api_secret") if isinstance(self.creds, dict) else None) or os.getenv("ASTER_API_SECRET", "")

    # ================= API publique =================

    async def connect(self):
        self._running = True
        if self.logger:
            self.logger("Aster: connecté")

    def book(self, sym: str) -> Optional[_Book]:
        return self._books.get((sym or "").upper())

    def get_book(self, sym: str) -> Optional[Tuple[float, float, float]]:
        b = self._books.get((sym or "").upper())
        if not b or b.bid is None or b.ask is None:
            return None
        return float(b.bid), float(b.ask), float(b.t or time.time())

    def get_l2_book(self, sym: str) -> Optional[Dict[str, List[Tuple[float, float]]]]:
        return self._l2.get((sym or "").upper())

    @property
    def books(self) -> List[str]:
        return list(self._books.keys())

    async def start(self, symbols: List[str]):
        if not self._running:
            self._running = True
            if self.logger:
                self.logger("Aster: connecté")

        to_add = [s.upper() for s in (symbols or []) if s and s.upper() not in self._symbols]
        if to_add:
            await self._warmup_rest(to_add)
            self._symbols.extend(to_add)

        await self._restart_ws()

        if not self._poller_task or self._poller_task.done():
            self._poller_task = asyncio.create_task(self._rest_bookticker_poller())
        if not self._watchdog_task or self._watchdog_task.done():
            self._watchdog_task = asyncio.create_task(self._stale_watchdog())

    async def subscribe_orderbook(self, symbol: str):
        s = (symbol or "").upper()
        if not s:
            return

        if s not in self._symbols:
            await self._warmup_rest([s])
            self._symbols.append(s)
            if self.logger:
                self.logger(f"Aster abonnement carnet: {s}")
            await self._restart_ws()

        if not self._poller_task or self._poller_task.done():
            self._poller_task = asyncio.create_task(self._rest_bookticker_poller())
        if not self._watchdog_task or self._watchdog_task.done():
            self._watchdog_task = asyncio.create_task(self._stale_watchdog())

    async def stop(self):
        self._running = False
        if self._poller_task:
            self._poller_task.cancel()
            self._poller_task = None
        if self._watchdog_task:
            self._watchdog_task.cancel()
            self._watchdog_task = None
        for t in self._ws_tasks:
            t.cancel()
        self._ws_tasks.clear()

    # ============== REST signés (balances futures) ==============

    async def get_fees(self) -> Dict[str, float]:
        # Valeurs par défaut si on n’a pas d’API dédiée
        return {"taker_bps": 5.0, "maker_bps": 1.0}

    async def get_futures_balance_usd(self) -> Optional[float]:
        """
        Lit la balance futures USDT/USDC via /fapi/v2(bis)/balance (compatible Binance fapi).
        Nécessite ASTER_API_KEY / ASTER_API_SECRET.
        Retourne la somme des walletBalance (USDT + USDC) en USD.
        """
        if not self._is_futures:
            return None
        if not self._api_key or not self._api_secret:
            return None

        async def _signed_get(path: str, params: Dict[str, str]) -> Optional[dict | list]:
            ts = int(time.time() * 1000)
            q = dict(params or {})
            q["timestamp"] = str(ts)
            q["recvWindow"] = "5000"
            query_str = urlencode(q)
            sig = hmac.new(self._api_secret.encode(), query_str.encode(), hashlib.sha256).hexdigest()
            url = f"{self.base_rest}{path}?{query_str}&signature={sig}"
            headers = {"X-MBX-APIKEY": self._api_key, "User-Agent": "arb-bot/1.1"}
            try:
                timeout = aiohttp.ClientTimeout(total=7)
                async with aiohttp.ClientSession(timeout=timeout) as sess:
                    async with sess.get(url, headers=headers) as r:
                        if r.status != 200:
                            return None
                        ct = (r.headers.get("Content-Type") or "")
                        if "json" not in ct:
                            return None
                        return await r.json()
            except Exception:
                return None

        # Essai v2 puis v3
        data = await _signed_get("/fapi/v2/balance", {})
        if data is None:
            data = await _signed_get("/fapi/v3/balance", {})
        if not isinstance(data, list):
            return None

        total = 0.0
        for row in data:
            try:
                asset = (row.get("asset") or "").upper()
                if asset in ("USDT", "USDC"):
                    wb = float(row.get("balance") or row.get("walletBalance") or 0.0)
                    total += wb
            except Exception:
                continue
        return total

    # ============== Gestion WS chunkés ==============

    async def _restart_ws(self):
        async with self._reconfigure_lock:
            for t in self._ws_tasks:
                t.cancel()
            self._ws_tasks.clear()

            if not self._running or not self._symbols:
                return

            chunks = self._chunk_symbols(self._symbols, PAIRS_PER_WS)
            for i, chunk in enumerate(chunks, 1):
                t = asyncio.create_task(self._ws_loop_chunk(i, list(chunk)))
                self._ws_tasks.append(t)

    def _chunk_symbols(self, symbols: List[str], size: int) -> List[List[str]]:
        up = [s.upper() for s in (symbols or []) if s]
        return [up[i : i + size] for i in range(0, len(up), size)]

    def _streams_for_chunk(self, symbols: List[str]) -> str:
        parts = []
        for s in symbols or []:
            s_l = s.lower()
            parts.append(f"{s_l}@depth@100ms")
            parts.append(f"{s_l}@bookTicker")
        return "/".join(parts)

    async def _ws_loop_chunk(self, idx: int, symbols: List[str]):
        backoff = RECONNECT_BASE_DELAY
        while self._running and symbols:
            streams = self._streams_for_chunk(symbols)
            url = f"{self.base_ws}?streams={streams}"
            try:
                if self.logger:
                    self.logger(f"Aster WS (chunk {idx}) connexion: streams={len(symbols)*2} - {symbols}")
                async with websockets.connect(
                    url,
                    ping_interval=WS_PING_INTERVAL,
                    ping_timeout=WS_PING_TIMEOUT,
                    max_size=None,
                ) as ws:
                    if self.logger:
                        self.logger(f"Aster WS (chunk {idx}) connecté - streams={len(symbols)*2}")
                    backoff = RECONNECT_BASE_DELAY

                    while self._running:
                        try:
                            msg = await asyncio.wait_for(
                                ws.recv(), timeout=WS_PING_INTERVAL + WS_PING_TIMEOUT + 5
                            )
                        except asyncio.TimeoutError:
                            try:
                                pong = await ws.ping()
                                await asyncio.wait_for(pong, timeout=WS_PING_TIMEOUT)
                                continue
                            except Exception:
                                raise
                        self._handle_ws_message(msg)

            except asyncio.CancelledError:
                return
            except Exception as e:
                if self.logger:
                    self.logger(f"Aster WS (chunk {idx}) erreur: {e}. Reconnexion...")
                await asyncio.sleep(backoff)
                backoff = min(RECONNECT_MAX_DELAY, backoff * 1.6)

    # ============== Parsing messages WS ==============

    def _touch(self, sym: str):
        self._last_update[sym] = time.time()

    def _handle_ws_message(self, msg: str):
        try:
            data = json.loads(msg)
        except Exception:
            return

        d = data.get("data") or data
        if not isinstance(d, dict):
            return

        # bookTicker
        if "s" in d and "b" in d and "a" in d:
            sym = (d.get("s") or "").upper()
            if not sym:
                return
            try:
                bid = float(d["b"])
                ask = float(d["a"])
            except Exception:
                return
            bk = self._books.get(sym) or _Book()
            bk.bid = bid
            bk.ask = ask
            bk.t = time.time()
            self._books[sym] = bk
            self._touch(sym)
            return

        # depth partiel -> top + 20 niveaux triés
        if "s" in d and "bids" in d and "asks" in d:
            sym = (d.get("s") or "").upper()
            if not sym:
                return
            bids = d.get("bids") or []
            asks = d.get("asks") or []

            try:
                top_bid = float(bids[0][0]) if bids else None
                top_ask = float(asks[0][0]) if asks else None
            except Exception:
                top_bid = top_ask = None

            if top_bid is not None and top_ask is not None:
                bk = self._books.get(sym) or _Book()
                bk.bid = top_bid
                bk.ask = top_ask
                bk.t = time.time()
                self._books[sym] = bk
                self._touch(sym)

            try:
                bids_lvls = [(float(p), float(q)) for p, q in bids if float(q) > 0][:20]
                asks_lvls = [(float(p), float(q)) for p, q in asks if float(q) > 0][:20]
                bids_lvls.sort(key=lambda x: x[0], reverse=True)
                asks_lvls.sort(key=lambda x: x[0])
                if bids_lvls or asks_lvls:
                    self._l2[sym] = {"bids": bids_lvls, "asks": asks_lvls}
            except Exception:
                pass

            return

    # ============== REST (warm-up & poller) ==============

    async def _warmup_rest(self, symbols: List[str]):
        if not symbols:
            return
        url_bulk = f"{self.base_rest}{self._rest_ticker_path}"
        try:
            timeout = aiohttp.ClientTimeout(total=REST_WARMUP_TIMEOUT)
            async with aiohttp.ClientSession(timeout=timeout) as sess:
                # bulk
                async with sess.get(url_bulk) as r:
                    if r.status == 200:
                        arr = await r.json()
                        want = set(s.upper() for s in symbols)
                        hit = 0
                        if isinstance(arr, list):
                            for row in arr:
                                sym = (row.get("symbol") or "").upper()
                                if sym and sym in want:
                                    try:
                                        bid = float(row["bidPrice"])
                                        ask = float(row["askPrice"])
                                    except Exception:
                                        continue
                                    self._books[sym] = _Book(bid, ask)
                                    self._touch(sym)
                                    hit += 1
                        if self.logger:
                            self.logger(f"Aster warm-up bulk: {hit}/{len(want)}")
                        return

                # fallback par symbole
                for s in symbols:
                    params = {"symbol": s.upper()}
                    async with sess.get(url_bulk, params=params) as r2:
                        if r2.status != 200:
                            continue
                        j = await r2.json()
                        sym = (j.get("symbol") or "").upper()
                        if not sym:
                            continue
                        try:
                            bid = float(j["bidPrice"])
                            ask = float(j["askPrice"])
                        except Exception:
                            continue
                        self._books[sym] = _Book(bid, ask)
                        self._touch(sym)
                        if self.logger:
                            self.logger(f"Aster warm-up {sym}: bid {bid} / ask {ask}")
        except Exception:
            pass

    async def _rest_bookticker_poller(self):
        url = f"{self.base_rest}{self._rest_ticker_path}"
        while self._running:
            try:
                syms_snapshot = list(self._symbols)
                if not syms_snapshot:
                    await asyncio.sleep(1.0)
                    continue

                timeout = aiohttp.ClientTimeout(total=5)
                async with aiohttp.ClientSession(timeout=timeout) as sess:
                    async with sess.get(url) as r:
                        if r.status == 200:
                            arr = await r.json()
                            if isinstance(arr, list):
                                idx = {row.get("symbol", "").upper(): row for row in arr}
                                now = time.time()
                                for s in syms_snapshot:
                                    row = idx.get(s.upper())
                                    if not row:
                                        continue
                                    try:
                                        bid = float(row["bidPrice"])
                                        ask = float(row["askPrice"])
                                    except Exception:
                                        continue
                                    bk = self._books.get(s.upper()) or _Book()
                                    bk.bid = bid
                                    bk.ask = ask
                                    bk.t = now
                                    self._books[s.upper()] = bk
                                    self._touch(s.upper())

                await asyncio.sleep(2.0)
            except asyncio.CancelledError:
                return
            except Exception:
                await asyncio.sleep(2.0)

    # ============== Watchdog stale/resub ==============

    async def _stale_watchdog(self):
        while self._running:
            try:
                now_s = time.time()
                stale_syms: List[str] = []
                for s in list(self._symbols):
                    last = self._last_update.get(s, 0.0)
                    if (now_s - last) * 1000.0 > STALE_MS:
                        stale_syms.append(s)

                if stale_syms and self.logger:
                    self.logger(f"Aster watchdog: {len(stale_syms)} symbole(s) stale: {stale_syms}")

                if stale_syms:
                    await self._warmup_rest(stale_syms)

                t_ms = int(now_s * 1000)
                for s in stale_syms:
                    last_try = self._last_resub_try_ms.get(s, 0)
                    if t_ms - last_try < RESUB_BACKOFF_MS:
                        continue
                    self._last_resub_try_ms[s] = t_ms
                    if self.logger:
                        self.logger(f"Aster watchdog: resub {s}")
                    await self.start([s])

            except asyncio.CancelledError:
                return
            except Exception as e:
                if self.logger:
                    self.logger(f"Aster watchdog erreur: {e!r}")
            finally:
                await asyncio.sleep(WATCHDOG_PERIOD_S)
