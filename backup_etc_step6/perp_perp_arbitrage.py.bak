# strategies/perp_perp_arbitrage.py
from __future__ import annotations
import asyncio
from typing import Dict, List, Optional, Tuple, Any, Deque
import time
from collections import deque
import math

from core.pnl_logger import CsvPNLLogger

def now_ms() -> int:
    return int(time.time() * 1000)

def _mid(bid: Optional[float], ask: Optional[float]) -> Optional[float]:
    if bid is None or ask is None:
        return None
    if bid <= 0 or ask <= 0:
        return None
    return (bid + ask) / 2.0

def _bps_from_prices(p1: float, p2: float) -> float:
    if p1 <= 0 or p2 <= 0:
        return 0.0
    return (p1 / p2 - 1.0) * 10_000.0


class PerpPerpArb:
    """
    Arbitrage perp HL ↔ Aster (paper).
    - Entrée symétrique: on trade si |net_adj_bps| >= entry_bps.
    - PnL ex-ante strictement > 0 (sécurité).
    - Anti-retapage: hits, réarmement, cooldown post-trade, quota/minute.
    - Fees dynamiques si venue expose get_fees().
    - Cash = cash + pnl_usd (pas de double comptage de fees).
    - NEW Étape 6: equity réelle venues (HL + Aster) => sizing auto.
    """

    def __init__(
        self,
        hl: Any,
        asr: Any,
        cfg: Dict[str, Any],
        active_pairs: List[str],
        risk: Dict[str, Any],
        notifier: Any,
        pnl_csv_path: str = "logs/arb_exec.csv",
        wallet_address: Optional[str] = None,
    ):
        self.hl = hl
        self.asr = asr
        self.cfg = cfg or {}
        self.active_pairs = list(active_pairs or [])
        self.risk = risk or {}
        self.notifier = notifier
        self.wallet_address = (wallet_address or "").strip()

        # Capital paper (fallback)
        self.initial_capital_usd: float = float(self.risk.get("paper_capital_usd_arb", 1000.0))
        self.cash_usd: float = self.initial_capital_usd
        self.equity_usd: float = self.initial_capital_usd

        # Coûts (défauts/fallback)
        fees_hl = float(self.cfg.get("hyperliquid", {}).get("fees", {}).get("taker_bps", 4.5))
        fees_as = float(self.cfg.get("aster", {}).get("fees", {}).get("taker_bps", 5.0))
        self.fees_bps: float = fees_hl + fees_as
        self.slip_bps: float = float(self.risk.get("slippage_bps_buffer", 6.0))
        self.gas_bps_per_roundtrip: float = float(self.risk.get("gas_bps_per_roundtrip", 3.0))
        self.gas_usd_per_trade: float = float(self.risk.get("gas_usd_per_trade", 0.25))

        self._pnl_logger = CsvPNLLogger(pnl_csv_path)
        self._symbol_map: Dict[str, Dict[str, str]] = dict(self.cfg.get("symbol_map", {}))

        # Anti-retapage & sizing
        self._cooldowns: Dict[str, int] = {}
        self._hits: Dict[str, int] = {}
        self._armed: Dict[str, bool] = {}
        self._last_entry_net: Dict[str, float] = {}
        self._last_exec_ts: Dict[str, int] = {}
        self._last_exec_mids: Dict[str, Tuple[float, float]] = {}
        self._per_min_notional: Dict[str, Deque[Tuple[int, float]]] = {}
        self._last_exec_symbol_ts: Dict[str, int] = {}  # pour retap_delay_ms (étape précédente)

        self._rearm_hyst_bps: float = float(self.risk.get("rearm_hysteresis_bps", 6.0))
        self._post_trade_cooldown_ms: int = int(self.risk.get("post_trade_cooldown_ms", 1000))
        self._min_mid_change_bps: float = float(self.risk.get("min_mid_change_bps", 3.0))
        self._max_usd_per_symbol_per_min: float = float(self.risk.get("max_usd_per_symbol_per_min", 2000.0))
        self._retap_delay_ms: int = int(self.risk.get("retap_delay_ms", 60_000))

        self._min_hits: int = int(self.risk.get("min_consecutive_hits", 3))
        self._signal_cooldown_ms: int = int(self.risk.get("signal_cooldown_ms", 400))

        # Sizing dynamique
        self._alloc_frac: float = float(self.risk.get("alloc_frac_per_trade", 0.2))  # 20% comme demandé
        self._notional_min: float = float(self.risk.get("notional_per_trade_min", 50.0))
        self._notional_max: float = float(self.risk.get("notional_per_trade_max", 10_000_000.0))

        # Rafraîchissements
        self.entry_bps: float = float(self.risk.get("spread_entry_bps", 25.0))
        self._fees_refresh_ms: int = int(self.risk.get("fees_refresh_ms", 10 * 60 * 1000))
        self._last_fees_refresh_ts: int = 0

        self._balances_refresh_ms: int = int(self.risk.get("balances_refresh_ms", 15_000))
        self._last_bal_refresh_ts: int = 0
        self._equity_dbg: Dict[str, float] = {}

    # ---------- Helpers ----------
    def _hl_book_tuple(self, sym_usdt: str) -> Tuple[Optional[float], Optional[float], Optional[float]]:
        coin = (self._symbol_map.get(sym_usdt, {}).get("hyperliquid") or sym_usdt).upper().replace("USDT", "")
        bk = self.hl.get_book(coin)
        if not bk or len(bk) < 2:
            return None, None, None
        return bk

    def _as_book_tuple(self, sym_usdt: str) -> Tuple[Optional[float], Optional[float], Optional[float]]:
        sym = (self._symbol_map.get(sym_usdt, {}).get("aster") or sym_usdt).upper()
        bk = self.asr.get_book(sym)
        if not bk or len(bk) < 2:
            return None, None, None
        return bk

    async def _maybe_refresh_fees(self, t_ms: int) -> None:
        if t_ms - self._last_fees_refresh_ts < self._fees_refresh_ms:
            return
        self._last_fees_refresh_ts = t_ms

        async def _pull(v: Any):
            try:
                fn = getattr(v, "get_fees", None)
                if fn is None: return None
                if asyncio.iscoroutinefunction(fn): return await fn()
                return fn()
            except Exception:
                return None

        hl_fees = await _pull(self.hl)
        as_fees = await _pull(self.asr)

        taker_hl = float(hl_fees.get("taker_bps")) if hl_fees and "taker_bps" in hl_fees else math.nan
        taker_as = float(as_fees.get("taker_bps")) if as_fees and "taker_bps" in as_fees else math.nan

        if not math.isnan(taker_hl) or not math.isnan(taker_as):
            hl_default = float(self.cfg.get("hyperliquid", {}).get("fees", {}).get("taker_bps", 4.5))
            as_default = float(self.cfg.get("aster", {}).get("fees", {}).get("taker_bps", 5.0))
            hl_bps = taker_hl if not math.isnan(taker_hl) else hl_default
            as_bps = taker_as if not math.isnan(taker_as) else as_default
            self.fees_bps = float(hl_bps) + float(as_bps)

    # ---------- Equity (NEW) ----------
    async def _refresh_equity_if_due(self, t_ms: int) -> None:
        if t_ms - self._last_bal_refresh_ts < self._balances_refresh_ms:
            return
        self._last_bal_refresh_ts = t_ms

        hl_eq = None
        as_eq = None

        # Hyperliquid: equity USD clearinghouse
        try:
            addr = self.wallet_address
            if addr:
                fn = getattr(self.hl, "get_equity_usd", None)
                if fn:
                    hl_eq = await fn(addr) if asyncio.iscoroutinefunction(fn) else fn(addr)
        except Exception:
            hl_eq = None

        # Aster: walletBalance (USDT/USDC) sur futures
        try:
            fn2 = getattr(self.asr, "get_futures_balance_usd", None)
            if fn2:
                as_eq = await fn2() if asyncio.iscoroutinefunction(fn2) else fn2()
        except Exception:
            as_eq = None

        # Agrégation simple (on-chain optionnel à ajouter plus tard)
        parts = []
        if isinstance(hl_eq, (int, float)) and hl_eq > 0:
            parts.append(("hl", float(hl_eq)))
        if isinstance(as_eq, (int, float)) and as_eq > 0:
            parts.append(("as", float(as_eq)))

        if parts:
            total = sum(v for _, v in parts)
            self.equity_usd = float(total)
            self._equity_dbg = {k: v for k, v in parts}
        else:
            # fallback = paper
            self.equity_usd = max(self.equity_usd, self.cash_usd)

    async def _notify_exec(self, text: str) -> None:
        try:
            await self.notifier.notify("Arb Exec", text)
        except Exception:
            try:
                self.notifier.notify_sync("Arb Exec", text)
            except Exception:
                pass

    # ---------- L2 helpers ----------
    def _get_l2_levels(self, venue: Any, sym: str, side: str) -> Optional[List[Tuple[float, float]]]:
        try:
            if venue is self.hl:
                bk = self.hl.get_l2_book(sym)
                if not bk or side not in bk:
                    return None
                return list(bk[side])[:20]
            return None
        except Exception:
            return None

    def _estimate_vwap(self, levels: List[Tuple[float, float]] | None, alloc_usd: float) -> Optional[float]:
        if not levels or alloc_usd <= 0:
            return None
        remaining = float(alloc_usd)
        cost = 0.0
        qty_acq = 0.0
        for px, qty in levels:
            if px <= 0 or qty <= 0:
                continue
            usd_liq = qty * px
            take_usd = min(usd_liq, remaining)
            take_qty = take_usd / px
            cost += take_qty * px
            qty_acq += take_qty
            remaining -= take_usd
            if remaining <= 1e-9:
                break
        if qty_acq <= 0:
            return None
        return cost / qty_acq

    # ---------- Core edge ----------
    def _net_edge_bps(self, sym_usdt: str, alloc_usd: float) -> Tuple[Optional[float], Optional[float], Optional[float]]:
        hl_bid, hl_ask, _ = self._hl_book_tuple(sym_usdt)
        as_bid, as_ask, _ = self._as_book_tuple(sym_usdt)
        mid_hl = _mid(hl_bid, hl_ask)
        mid_as = _mid(as_bid, as_ask)
        if mid_hl is None or mid_as is None or mid_hl <= 0 or mid_as <= 0:
            return None, None, None

        raw_bps = _bps_from_prices(mid_hl, mid_as)
        fees_and_gas = self.fees_bps + self.gas_bps_per_roundtrip
        net_mid_bps = raw_bps - fees_and_gas
        return net_mid_bps, mid_hl, mid_as

    # ---------- Tick helpers ----------
    def _depth_slippage_bps(self, sym_usdt: str, side: int, alloc_usd: float) -> Optional[float]:
        hl_bid, hl_ask, _ = self._hl_book_tuple(sym_usdt)
        as_bid, as_ask, _ = self._as_book_tuple(sym_usdt)
        mid_hl = _mid(hl_bid, hl_ask)
        mid_as = _mid(as_bid, as_ask)
        if mid_hl is None or mid_as is None or mid_hl <= 0 or mid_as <= 0:
            return None

        m = self._symbol_map.get(sym_usdt, {})
        hl_sym = (m.get("hyperliquid") or sym_usdt).upper().replace("USDT", "")
        as_sym = (m.get("aster") or sym_usdt).upper()

        total_bps = 0.0
        if side > 0:
            asks_hl = self._get_l2_levels(self.hl, hl_sym, side="asks")
            vwap_buy_hl = self._estimate_vwap(asks_hl, alloc_usd) if asks_hl else None
            if vwap_buy_hl and mid_hl > 0:
                total_bps += max(0.0, _bps_from_prices(vwap_buy_hl, mid_hl))
            bids_as = self._get_l2_levels(self.asr, as_sym, side="bids")
            vwap_sell_as = self._estimate_vwap(bids_as, alloc_usd) if bids_as else None
            if vwap_sell_as and mid_as > 0:
                total_bps += max(0.0, _bps_from_prices(mid_as, vwap_sell_as))
        else:
            asks_as = self._get_l2_levels(self.asr, as_sym, side="asks")
            vwap_buy_as = self._estimate_vwap(asks_as, alloc_usd) if asks_as else None
            if vwap_buy_as and mid_as > 0:
                total_bps += max(0.0, _bps_from_prices(vwap_buy_as, mid_as))
            bids_hl = self._get_l2_levels(self.hl, hl_sym, side="bids")
            vwap_sell_hl = self._estimate_vwap(bids_hl, alloc_usd) if bids_hl else None
            if vwap_sell_hl and mid_hl > 0:
                total_bps += max(0.0, _bps_from_prices(mid_hl, vwap_sell_hl))
        return total_bps

    def _bump_hit(self, sym: str, ok_entry: bool) -> bool:
        h = int(self._hits.get(sym, 0))
        if ok_entry:
            h += 1
        else:
            h = 0
        self._hits[sym] = h
        return h >= self._min_hits

    def _armed_check_and_update(self, sym: str, abs_edge: float, entry_bps: float, net_adj_bps: float) -> bool:
        armed = bool(self._armed.get(sym, False))
        if not armed:
            self._armed[sym] = True
            return False
        if abs_edge < max(0.0, entry_bps - self._rearm_hyst_bps):
            self._armed[sym] = False
            return False
        return True

    def _post_trade_windows_ok(self, sym: str, t_ms: int, alloc_usd: float) -> bool:
        # cooldown global
        last = int(self._last_exec_ts.get(sym, 0))
        if t_ms - last < self._post_trade_cooldown_ms:
            return False
        # cooldown par symbole (retap)
        last_sym = int(self._last_exec_symbol_ts.get(sym, 0))
        if t_ms - last_sym < self._retap_delay_ms:
            return False
        # quota/minute
        q = self._per_min_notional.get(sym)
        if q is None:
            return True
        while q and (t_ms - q[0][0] > 60_000):
            q.popleft()
        s = sum(v for _, v in q)
        return (s + float(alloc_usd)) <= self._max_usd_per_symbol_per_min

    def _mids_changed_enough(self, sym: str, mid_hl: float, mid_as: float) -> bool:
        last = self._last_exec_mids.get(sym)
        if not last:
            return True
        p_hl, p_as = last
        if p_hl <= 0 or p_as <= 0:
            return True
        bps_hl = abs(_bps_from_prices(mid_hl, p_hl))
        bps_as = abs(_bps_from_prices(mid_as, p_as))
        return (bps_hl >= self._min_mid_change_bps) or (bps_as >= self._min_mid_change_bps)

    # ---------- Execution (paper) ----------
    async def _do_scalp(
        self,
        sym: str,
        side: int,
        alloc_usd: float,
        mid_hl: float,
        mid_as: float,
        net_mid_bps: float,
        depth_slip_bps: float,
        net_adj_bps: float,
    ) -> None:
        pnl_usd = alloc_usd * (abs(net_adj_bps) / 10_000.0)
        self.cash_usd += pnl_usd
        # equity_usd est recalculée périodiquement depuis les venues (fallback = paper cash)
        self.equity_usd = max(self.equity_usd, self.cash_usd)

        direction = "Long HL / Short AS" if side > 0 else "Long AS / Short HL"
        msg = (
            f"[SCALP] {sym} | {direction} | net_mid={net_mid_bps:.2f} bps | depth_slip={depth_slip_bps:.2f} bps "
            f"=> net_adj={net_adj_bps:.2f} bps | HL_mid={mid_hl:.6f} | AS_mid={mid_as:.6f} "
            f"| alloc={alloc_usd:.2f} | pnl={pnl_usd:.2f} USD | cash={self.cash_usd:.2f}"
        )
        await self._notify_exec(msg)
        self._pnl_logger.log_exec({
            "symbol": sym,
            "side": direction,
            "net_mid_bps": float(net_mid_bps),
            "depth_slip_bps": float(depth_slip_bps),
            "net_adj_bps": float(net_adj_bps),

            # Compat CSV actuel
            "net_bps_open": float(net_adj_bps),
            "entry_fees_usd": float(alloc_usd) * (self.fees_bps / 10_000.0),
            "effective_alloc_usd": float(alloc_usd),

            "hl_mid": float(mid_hl),
            "as_mid": float(mid_as),
            "alloc_gross_usd": float(alloc_usd),
            "pnl_usd": float(pnl_usd),
            "cash_usd_after": float(self.cash_usd),
            "equity_usd_after": float(max(self.equity_usd, self.cash_usd)),
        })

    # ---------- Main loop ----------
    async def tick(self) -> None:
        t = now_ms()
        # 1) frais dynamiques
        await self._maybe_refresh_fees(t)
        # 2) equity venue-réelle (NEW)
        await self._refresh_equity_if_due(t)

        entry_bps = self.entry_bps

        # Sizing dynamique 20% de l’equity venues (borné par min/max)
        alloc_base = max(self._notional_min, min(self._notional_max, self._alloc_frac * max(0.0, self.equity_usd)))
        alloc_per_trade = alloc_base

        for sym in self.active_pairs:
            if self.cash_usd <= 0:
                break

            last_signal = self._cooldowns.get(sym, 0)
            if t - last_signal < self._signal_cooldown_ms:
                continue

            net_mid_bps, mid_hl, mid_as = self._net_edge_bps(sym, alloc_usd=alloc_per_trade)
            if net_mid_bps is None or mid_hl is None or mid_as is None:
                self._bump_hit(sym, False)
                continue

            side_mid = 1 if net_mid_bps > 0 else -1
            depth_slip_bps = self._depth_slippage_bps(sym, side_mid, alloc_per_trade)
            if depth_slip_bps is None:
                depth_slip_bps = self.slip_bps

            net_adj_bps = net_mid_bps - max(0.0, depth_slip_bps)

            ok_entry = abs(net_adj_bps) >= entry_bps
            if not self._bump_hit(sym, ok_entry):
                continue

            if not self._armed_check_and_update(sym, abs(net_adj_bps), entry_bps, net_adj_bps):
                continue
            if not self._post_trade_windows_ok(sym, t, alloc_per_trade):
                continue
            if not self._mids_changed_enough(sym, mid_hl, mid_as):
                continue

            alloc = min(alloc_per_trade, self.cash_usd)
            if alloc <= 0:
                continue

            pnl_est_usd = alloc * (abs(net_adj_bps) / 10_000.0)
            if pnl_est_usd <= 0:
                continue

            side = 1 if net_adj_bps > 0 else -1

            self._cooldowns[sym] = t
            await self._do_scalp(sym, side, alloc, mid_hl, mid_as, net_mid_bps, depth_slip_bps, net_adj_bps)

            self._armed[sym] = False
            self._last_entry_net[sym] = net_adj_bps
            self._last_exec_ts[sym] = t
            self._last_exec_mids[sym] = (mid_hl, mid_as)
            self._last_exec_symbol_ts[sym] = t

            q = self._per_min_notional.get(sym)
            if q is None:
                q = deque()
                self._per_min_notional[sym] = q
            q.append((t, float(alloc)))
