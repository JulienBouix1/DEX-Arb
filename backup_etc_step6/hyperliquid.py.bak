# venues/hyperliquid.py
from __future__ import annotations

import asyncio
import logging
import json
import time
import random
from typing import List, Tuple, Optional, Dict, Any, Set

import websockets
import aiohttp

log = logging.getLogger("hyperliquid")

# Pacing et timeouts
SUB_RATE_LIMIT_HZ = 8.0            # retour à 8/s + petit jitter
PING_INTERVAL_S   = 20.0
RECV_TIMEOUT_S    = 90.0
RECONNECT_BACKOFF_BASE = 1.0
RECONNECT_BACKOFF_MAX  = 8.0

# Watchdog: ré-envoie les subs si un coin est manquant/stale
WATCHDOG_PERIOD_S = 4.0
STALE_BOOK_S      = 15.0

class Hyperliquid:
    def __init__(self, ws_url: str, rest_url: str, creds: Optional[dict] = None):
        self.ws_url = ws_url
        self.rest_url = rest_url.rstrip("/")
        self.creds = creds or {}

        self._ws: Optional[websockets.WebSocketClientProtocol] = None
        self._reader_task: Optional[asyncio.Task] = None
        self._pinger_task: Optional[asyncio.Task] = None
        self._sender_task: Optional[asyncio.Task] = None
        self._manager_task: Optional[asyncio.Task] = None
        self._watchdog_task: Optional[asyncio.Task] = None

        # Subscriptions
        self._subs: Set[str] = set()          # coins demandés (uppercase)
        self._send_queue: asyncio.Queue[dict] = asyncio.Queue()

        # Top-of-book (coin -> (bid, ask, ts))
        self._top: Dict[str, Tuple[float, float, float]] = {}

        # L2 (coin -> {"bids":[(px,qty),...], "asks":[(px,qty),...]})
        self._l2: Dict[str, Dict[str, List[Tuple[float, float]]]] = {}

        self._dbg_seen = 0
        self._lock = asyncio.Lock()
        self._running = False

    # ---------------- Public API ----------------

    @property
    def books(self) -> List[str]:
        return sorted(list(self._top.keys()))

    def get_book(self, coin: str) -> Optional[Tuple[float, float, float]]:
        if not coin:
            return None
        return self._top.get(coin.upper())

    def get_l2_book(self, coin: str) -> Optional[Dict[str, List[Tuple[float, float]]]]:
        if not coin:
            return None
        return self._l2.get(coin.upper())

    async def connect(self):
        if self._running:
            return
        self._running = True
        if not self._manager_task or self._manager_task.done():
            self._manager_task = asyncio.create_task(self._open_ws_and_loops())

    async def stop(self):
        self._running = False
        tasks = [t for t in (self._reader_task, self._pinger_task, self._sender_task, self._manager_task, self._watchdog_task) if t]
        for t in tasks:
            t.cancel()
        self._reader_task = self._pinger_task = self._sender_task = self._manager_task = self._watchdog_task = None
        try:
            if self._ws:
                await self._ws.close()
        except Exception:
            pass
        self._ws = None

    async def subscribe_orderbook(self, coin: str):
        """
        Abonnement BBO d'abord (mid rapide), puis L2.
        Idempotent, thread-safe, **et** le watchdog ré-enverra si besoin.
        """
        c = (coin or "").upper().strip()
        if not c:
            return
        async with self._lock:
            if c not in self._subs:
                self._subs.add(c)
            # BBO AVANT L2 (priorité au mid)
            await self._send_queue.put({"method": "subscribe", "subscription": {"type": "bbo",    "coin": c}})
            await self._send_queue.put({"method": "subscribe", "subscription": {"type": "l2Book", "coin": c}})
            print(f"HL abonnement carnet (queued): {c}")

    async def cancel_all(self, symbol: str) -> None:
        return

    async def place_order(self, symbol: str, side: str, qty: float,
                          order_type: str = "MARKET", price: float | None = None) -> dict:
        return {"ok": False, "mode": "paper", "venue": "HYPERLIQ",
                "symbol": symbol, "side": side, "qty": qty,
                "type": order_type, "price": price}

    async def get_fees(self) -> Dict[str, float]:
        url = f"{self.rest_url}/info".rstrip("/")
        payload = {"type": "metaAndAssetCtxs"}
        try:
            timeout = aiohttp.ClientTimeout(total=6)
            async with aiohttp.ClientSession(timeout=timeout) as sess:
                async with sess.post(url, json=payload) as r:
                    if r.status != 200:
                        raise RuntimeError(f"HTTP {r.status}")
                    j = await r.json()
                    fees = (j or {}).get("meta", {}).get("fees", {})
                    taker = float(fees.get("taker", 0.00045)) * 10_000.0
                    maker = float(fees.get("maker", 0.00020)) * 10_000.0
                    return {"taker_bps": taker, "maker_bps": maker}
        except Exception:
            return {"taker_bps": 4.5, "maker_bps": 2.0}

    async def get_equity_usd(self, user_address: str) -> Optional[float]:
        """
        Lecture publique via /info {type: 'clearinghouseState', user: <EVM address>}.
        On extrait 'marginSummary.accountValue' (USD). Retourne None si indisponible.
        """
        addr = (user_address or "").strip()
        if not addr:
            return None
        url = f"{self.rest_url}/info"
        payload = {"type": "clearinghouseState", "user": addr}
        try:
            timeout = aiohttp.ClientTimeout(total=7)
            async with aiohttp.ClientSession(timeout=timeout) as sess:
                async with sess.post(url, json=payload) as r:
                    if r.status != 200:
                        return None
                    j = await r.json()
                    # Formats observés : marginSummary ou crossMarginSummary
                    ms = (j or {}).get("marginSummary") or (j or {}).get("crossMarginSummary") or {}
                    v = ms.get("accountValue")
                    if v is None:
                        # Fallback certains retours mettent des nombres natifs
                        v = (j or {}).get("accountValue")
                    if v is None:
                        return None
                    return float(v)
        except Exception:
            return None

    # ---------------- Internals ----------------

    async def _open_ws_and_loops(self):
        backoff = RECONNECT_BACKOFF_BASE
        while self._running:
            try:
                self._ws = await websockets.connect(self.ws_url, ping_interval=None)
                print("Hyperliquid WS connecté")
                backoff = RECONNECT_BACKOFF_BASE

                if not self._reader_task or self._reader_task.done():
                    self._reader_task = asyncio.create_task(self._reader_loop())
                if not self._pinger_task or self._pinger_task.done():
                    self._pinger_task = asyncio.create_task(self._ping_loop())
                if not self._sender_task or self._sender_task.done():
                    self._sender_task = asyncio.create_task(self._sender_loop())
                if not self._watchdog_task or self._watchdog_task.done():
                    self._watchdog_task = asyncio.create_task(self._watchdog_loop())

                # Rejoue les souscriptions existantes
                async with self._lock:
                    for c in self._subs:
                        await self._send_queue.put({"method": "subscribe", "subscription": {"type": "bbo",    "coin": c}})
                        await self._send_queue.put({"method": "subscribe", "subscription": {"type": "l2Book", "coin": c}})

                while self._running and self._ws and not self._reader_task.done():
                    await asyncio.sleep(0.5)

            except asyncio.CancelledError:
                break
            except Exception as e:
                log.warning(f"Hyperliquid: reconnect dans {backoff:.1f}s (err: {e})")
                await asyncio.sleep(backoff)
                backoff = min(RECONNECT_BACKOFF_MAX, backoff * 1.6)

    async def _ping_loop(self):
        while self._running:
            try:
                if self._ws is not None:
                    await self._ws.send(json.dumps({"method": "ping"}))
                await asyncio.sleep(PING_INTERVAL_S)
            except asyncio.CancelledError:
                return
            except Exception:
                await asyncio.sleep(3.0)

    async def _sender_loop(self):
        base_delay = 1.0 / max(1.0, SUB_RATE_LIMIT_HZ)
        while self._running:
            try:
                msg = await self._send_queue.get()
                if self._ws is None:
                    await asyncio.sleep(0.5)
                    await self._send_queue.put(msg)
                    continue
                try:
                    await self._ws.send(json.dumps(msg))
                except Exception:
                    await self._send_queue.put(msg)
                    await asyncio.sleep(0.5)
                    continue
                await asyncio.sleep(base_delay * (1.0 + random.uniform(0.0, 0.2)))
            except asyncio.CancelledError:
                return
            except Exception:
                await asyncio.sleep(base_delay)

    async def _reader_loop(self):
        assert self._ws is not None
        while self._running:
            try:
                raw = await asyncio.wait_for(self._ws.recv(), timeout=RECV_TIMEOUT_S)
                if raw is None:
                    continue

                try:
                    data = json.loads(raw)
                except Exception as e:
                    log.error(f"HL json decode err: {e} / raw={raw[:160]}")
                    continue

                if not isinstance(data, dict):
                    continue

                ch = data.get("channel")
                dd = data.get("data", {})

                if self._dbg_seen < 3 and ch:
                    print(f"(HL dbg) channel={ch} data_keys={list(dd.keys()) if isinstance(dd, dict) else type(dd)}")
                    self._dbg_seen += 1

                if ch == "subscriptionResponse":
                    sub = dd.get("subscription") if isinstance(dd, dict) else None
                    if isinstance(sub, dict):
                        coin = (sub.get("coin") or "").upper()
                        typ = sub.get("type")
                        if coin and typ:
                            print(f"HL souscription confirmée: {typ} {coin}")
                    continue

                if ch == "l2Book" and isinstance(dd, dict):
                    coin = (dd.get("coin") or dd.get("symbol") or "").upper()
                    if not coin:
                        continue
                    levels = dd.get("levels")
                    best_bid = best_ask = 0.0
                    bids_list: List[Tuple[float, float]] = []
                    asks_list: List[Tuple[float, float]] = []
                    if isinstance(levels, list) and len(levels) >= 2:
                        try:
                            rb = levels[0]; ra = levels[1]
                            def lv(x):
                                if isinstance(x, dict):
                                    return (float(x["px"]), float(x["sz"]))
                                return (float(x[0]), float(x[1]))
                            bids_list = [lv(x) for x in rb if float(lv(x)[1]) > 0][:20]
                            asks_list = [lv(x) for x in ra if float(lv(x)[1]) > 0][:20]
                            if bids_list and asks_list:
                                bids_list.sort(key=lambda x: x[0], reverse=True)
                                asks_list.sort(key=lambda x: x[0])
                                best_bid = bids_list[0][0]; best_ask = asks_list[0][0]
                        except Exception as e:
                            log.error(f"HL l2Book parse err: {e}")
                    elif "bids" in dd and "asks" in dd:
                        try:
                            bids_list = [(float(p), float(q)) for p, q in dd["bids"] if float(q) > 0][:20]
                            asks_list = [(float(p), float(q)) for p, q in dd["asks"] if float(q) > 0][:20]
                            if bids_list and asks_list:
                                bids_list.sort(key=lambda x: x[0], reverse=True)
                                asks_list.sort(key=lambda x: x[0])
                                best_bid = bids_list[0][0]; best_ask = asks_list[0][0]
                        except Exception as e:
                            log.error(f"HL l2Book alt parse err: {e}")
                    if bids_list or asks_list:
                        self._l2[coin] = {"bids": bids_list, "asks": asks_list}
                    if best_bid > 0.0 and best_ask > 0.0:
                        self._top[coin] = (best_bid, best_ask, time.time())

                elif ch == "bbo" and isinstance(dd, dict):
                    coin = (dd.get("coin") or dd.get("symbol") or "").upper()
                    bbo = dd.get("bbo")
                    if coin and isinstance(bbo, list) and len(bbo) == 2:
                        bid, ask = bbo
                        try:
                            bid_p = float(bid["px"]) if bid else 0.0
                            ask_p = float(ask["px"]) if ask else 0.0
                        except Exception:
                            bid_p = ask_p = 0.0
                        if bid_p > 0.0 and ask_p > 0.0:
                            self._top[coin] = (bid_p, ask_p, time.time())

            except asyncio.TimeoutError:
                continue
            except websockets.ConnectionClosed:
                print("Hyperliquid WS fermé. Tentative de reconnexion…")
                return
            except asyncio.CancelledError:
                return
            except Exception as e:
                log.error(f"HL reader err: {e}")
                await asyncio.sleep(0.1)

    async def _watchdog_loop(self):
        """
        Si un coin souscrit n'a pas de BBO récent, on **ré-envoie** les souscriptions (BBO+L2).
        """
        while self._running:
            try:
                now = time.time()
                async with self._lock:
                    subs_snapshot = list(self._subs)
                for c in subs_snapshot:
                    tup = self._top.get(c)
                    stale = True
                    if tup and len(tup) == 3:
                        _, _, ts = tup
                        stale = (now - float(ts)) > STALE_BOOK_S
                    if stale:
                        # ré-enqueue (BBO avant L2)
                        await self._send_queue.put({"method": "subscribe", "subscription": {"type": "bbo", "coin": c}})
                        await self._send_queue.put({"method": "subscribe", "subscription": {"type": "l2Book", "coin": c}})
                await asyncio.sleep(WATCHDOG_PERIOD_S)
            except asyncio.CancelledError:
                return
            except Exception:
                await asyncio.sleep(WATCHDOG_PERIOD_S)
